#!/bin/perl
use strict;

# =============================================================================
# CLI interface
# =============================================================================
package Cmd;
sub new
{
    my ($class, $name, $desc, $routine) = @_;

    my $this = {
        name => $name,
        description => $desc,
        routine => $routine,
        subroutines => {},
    };
    bless $this, $class;
    return $this;
}

# -----------------------------------------------------------------------------

sub knows
{
    my ($this, $name) = @_;
    if ($name && defined $this->{subroutines}->{$name}) {
        return 1;
    }
    return 0;
}

# -----------------------------------------------------------------------------

sub add_sub($$)
{
    my ($this, $subCmd) = @_;
    if ($this->knows($subCmd->{name})) {
        die "Duplicate command name $this->{name}::\"$subCmd->{name}\"";
    }
    $this->{subroutines}->{$subCmd->{name}} = $subCmd;
}

# -----------------------------------------------------------------------------

sub get_sub($$)
{
    my ($this, $name) = @_;
    return $this->{subroutines}->{$name}
}

# -----------------------------------------------------------------------------

sub run
{
    my ($this) = shift;
    return $this->{routine}($this, @_);
}

# -----------------------------------------------------------------------------

sub help
{
    my ($this, @argv) = @_;
    my $cmds = join ( '|', keys %{$this->{subroutines}});
    print "Usage: $this->{name} [$cmds] - $this->{description}\n";
    for my $cmd ( values %{$this->{subroutines}}) {
        print "    $cmd->{name} - $cmd->{description}\n"
    }
    if (@argv) {
        print "\n";
        print "Can't parse: \"" . join (' ', @argv) . "\"\n";
        return -1
    }
}

# -----------------------------------------------------------------------------

sub process
{
    my ($this, $cmd, @a) = @_;
    my $sub;
    if ($sub = $this->get_sub($cmd)) {
        return $sub->run(@a);

    } else {
        return $this->help($cmd, @a);
    }
}

# =============================================================================
# LOGGING
# =============================================================================

sub LOG {
    our $g_log_level;
    my $level = shift;
    if ($level <= $g_log_level) {
        printf @_;
        print "\n";
    }
}

# -----------------------------------------------------------------------------

sub set_log_level {
    our $g_log_level = shift;
}

# -----------------------------------------------------------------------------

sub DEBUG { LOG(3, @_); }

# -----------------------------------------------------------------------------

sub DUMP { LOG(4, @_); }

# =============================================================================
# Files
# =============================================================================

sub Makefile {
    our $OUTDIR;
    my ($name) = @_;
    return <<ENDMAKEFILE;
MAKEFLAGS += --no-builtin-rules

OUTDIR := $OUTDIR

.PHONY: pdf

pdf: ../$name.pdf

../$name.pdf: $name.tex |\${OUTDIR}
	pdflatex -output-directory \${OUTDIR} \$<
	mv \${OUTDIR}/$name.pdf \$@

\${OUTDIR}:
	echo "#  make \$@"
	mkdir \$@

clean:
	rm -rf \${OUTDIR}

pack: pdf
    git diff-index --quiet HEAD
	tar -cvf ${OUTDIR}/src.tar .git
ENDMAKEFILE
}

# -----------------------------------------------------------------------------

sub gitignore {
    our $OUTDIR;
    return <<ENDGITIGNORE;
$OUTDIR
ENDGITIGNORE
}

# =============================================================================
# Auxiliary
# =============================================================================

sub git_add {
    my $msg;
    my ($fname) = @_;

    `git add "$fname"`; !$?
        || die "$msg\n Can't add \"$fname\" to repository"; DUMP $msg;

   our $isCommitRequired = "true";
}

# -----------------------------------------------------------------------------

sub git_commit {
    my $message = shift;
    my $msg;
    our $isCommitRequired;
    if ($isCommitRequired) {
        $msg = `git commit -m "$message"`; !$?
            || die "$msg\n Can't perform commit"
    }
}

# -----------------------------------------------------------------------------

sub git_init {
    my $name = shift;
    my $msg;

    $msg = `git init`; !$?
        || die "$msg\nCan't initialise repository"; DUMP $msg;

    unlink glob ".git/hooks/*.sample";

    open (my $description, ">", ".git/description");
    print $description "Document \"$name\" repository (version " . version() . ")\n" .
                       "Ilya Kuzmin (i.g.kuzmin.spb\@gmail.com) (c)\n";
    close $description;

    open (my $gitignore, ">", ".gitignore");
    print $gitignore gitignore;
    close $gitignore;

    git_add ".gitignore";
}

# -----------------------------------------------------------------------------

sub touch {
    my $fname = shift;
    open my $fh, ">>", "$fname";
    print $fh "";
    close $fh;
}

# -----------------------------------------------------------------------------

sub version {
    return "1.0"
}

# =============================================================================
# Commands Implementation
# =============================================================================


sub cmd_new{
    my ($this, $name, @argv) = @_;
    my $msg;
    if ($name) {
        if (! -d $name) {
            DEBUG("Create \"$name\"");
            mkdir $name;
        }
        chdir $name;
        if (! -d ".git") {
            DEBUG("#  Initialise repository");
            git_init "$name"
        }
        if (! -f "Makefile") {
            DEBUG("#  Populate Makefile");
            open (my $mkfile, ">", "Makefile")
                || die "Can't create \"Makefile\""; DUMP $msg;
            print $mkfile Makefile $name;
            close $mkfile;
            git_add "Makefile";

        }
        if (! -f "$name.tex") {
            touch "$name.tex";
            git_add "$name.tex";
        }
        git_commit "Initial commit";
        if (! -s "$name.tex") {
            exec "vim +TTemplate\\ ru-article $name.tex";
        }
        exec "vim $name.tex";
    }
    return 0;
}

# -----------------------------------------------------------------------------

sub init_cmds()
{
    my $cmd = new Cmd('doc', "Document processing wrapper");
    $cmd->add_sub( new Cmd('new', "Initialise new document", \&cmd_new));
    return $cmd
}

# =============================================================================

sub main
{
    set_log_level(3);
    our $OUTDIR = ".out";

    my $cmd_list = init_cmds;
    $cmd_list->process(@_);
}

# -----------------------------------------------------------------------------

exit main @ARGV;
